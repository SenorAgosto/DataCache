TODO: 

- Ensure we can only call SetDataCache once

- Remove DataCache&, in UsingDataCacheIn add static set/get functions for the active data cache.
  Then I won't need to pass an instance to DataBlocks. Make a static DataCache that is the
  default. If client code wants to change the DataCache being used (as in they want more than 
  one) then they'll have to change. 

- Create Compile Time counter to implement DataBlockId. Each time we instantiate a DataBlock<> object it has a new unique compile time "field ID". This field ID will be used to register the field with the DataCache. 

- Move the mapping of local field ID to registered field ID to compile time.

- Answer the question of whether DataCache should be a singleton or not.
  If it is not going to be a singleton, I think I'll have to figure out a way to
  use variadic templates (or type lists) to instantiate it. So that it can create
  all the contained DataBlockCollections for each field ID registered. I'll need 
  a compile time mapping from field ID to field Type. 

- Consider implementing a traits class for specifying the counter type. 
  Defaulting to std::atomic<std::size_t> might be annoying for some users.
